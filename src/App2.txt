import { useState, useRef, useEffect } from 'react';
import * as faceapi from "@vladmandic/face-api";
import { Step1, Step2, Step3, Step4, FinalResult } from "./Steps";
import "../src/index.css"

import Header from "./components/header";
import Footer from "./components/footer";
import Puzzle from "./components/puzzle ";


export default function App() {
    const [currentStep, setCurrentStep] = useState(1);
    const [emotion, setEmotion] = useState({ name: "Í∞êÏßÄ Ï§ë...", emoji: "üòê", confidence: 0 });
    const [firstResult, setFirstResult] = useState(null);
    const [secondResult, setSecondResult] = useState(null);
    const [isModelReady, setIsModelReady] = useState(false);

    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const videoRef2 = useRef(null);
    const canvasRef2 = useRef(null);

    const detectionInterval = useRef(null);

    // ‚úÖ Î™®Îç∏ Î°úÎìú
    useEffect(() => {
        const loadModels = async () => {
            await faceapi.nets.tinyFaceDetector.loadFromUri("/models");
            await faceapi.nets.faceExpressionNet.loadFromUri("/models");
            console.log("‚úÖ face-api.js Î™®Îç∏ Î°úÎìú ÏôÑÎ£å");
            setIsModelReady(true);
        };
        loadModels();
    }, []);

    // ‚úÖ Ïπ¥Î©îÎùº ÏãúÏûë
    const startCamera = async (videoElement) => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            if (videoElement.current) {
                videoElement.current.srcObject = stream;
            }
        } catch (err) {
            alert("Ïπ¥Î©îÎùº Ïó∞Í≤∞ Ïã§Ìå®: " + err.message);
        }
    };

    // ‚úÖ Í∞êÏ†ï Ïù∏Ïãù ÏãúÏûë
    const startDetection = (videoElement, saveResultCallback) => {
        if (!videoElement.current) return;

        detectionInterval.current = setInterval(async () => {
            const detections = await faceapi
                .detectSingleFace(videoElement.current, new faceapi.TinyFaceDetectorOptions())
                .withFaceExpressions();

            if (detections && detections.expressions) {
                const sorted = Object.entries(detections.expressions).sort((a, b) => b[1] - a[1]);
                const [bestEmotion, confidence] = sorted[0];

                const emojiMap = {
                    happy: "üòä",
                    sad: "üò¢",
                    angry: "üò†",
                    fearful: "üò®",
                    disgusted: "ü§¢",
                    surprised: "üò≤",
                    neutral: "üòê",
                };

                const result = {
                    name: bestEmotion,
                    emoji: emojiMap[bestEmotion] || "üòê",
                    confidence: Math.round(confidence * 100),
                };

                setEmotion(result);
                if (saveResultCallback) {
                    saveResultCallback(result);
                }
            }
        }, 500);
    };

    // ‚úÖ Í∞êÏ†ï Ïù∏Ïãù Ï§ëÏßÄ
    const stopDetection = () => {
        if (detectionInterval.current) {
            clearInterval(detectionInterval.current);
            detectionInterval.current = null;
        }
    };

    // ‚úÖ Îã®Í≥Ñ ÏßÑÌñâ
    const goStep2 = async () => {
        if (!isModelReady) {
            alert("Î™®Îç∏Ïù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.");
            return;
        }
        await startCamera(videoRef);
        setCurrentStep(2);
        startDetection(videoRef, setFirstResult);
    };

    const goStep3 = () => {
        stopDetection();
        setCurrentStep(3);
    };

    const goStep4 = async () => {
        await startCamera(videoRef2);
        setCurrentStep(4);
        startDetection(videoRef2, setSecondResult);
    };

    const goResult = () => {
        stopDetection();
        setCurrentStep(5);
    };

    const restart = () => {
        stopDetection();
        setEmotion({ name: "Í∞êÏßÄ Ï§ë...", emoji: "üòê", confidence: 0 });
        setFirstResult(null);
        setSecondResult(null);
        setCurrentStep(1);
    };

    return (
        <div className="container">
            <Header />


            <div className="main-puzzle-container">
                <Puzzle PuzzleStatus={currentStep}/>

                {currentStep === 1 && <Step1 onNext={goStep2} />}
                {currentStep === 2 && (
                    <Step2
                        onNext={goStep3}
                        videoRef={videoRef}
                        canvasRef={canvasRef}
                        emotion={emotion}
                    />
                )}
                {currentStep === 3 && <Step3 onNext={goStep4} />}
                {currentStep === 4 && (
                    <Step4
                        onNext={goResult}
                        videoRef2={videoRef2}
                        canvasRef2={canvasRef2}
                        emotion={emotion}
                    />
                )}
                {currentStep === 5 && (
                    <FinalResult firstResult={firstResult} secondResult={secondResult} onRestart={restart} />
                )}
            </div>


            <Footer />
        </div>
    );
}
